<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DarkRift: First Network Code</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=DM+Sans&display=swap" rel="stylesheet">
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="dr2_stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="dr2_logo.svg"/></td>
  <td id="projectalign">
   <div id="projectname">DarkRift<span id="projectnumber">&#160;2.11.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_getting_started_4_first_network_code.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">First Network Code </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md226"></a>
Spawning Players</h1>
<p >The first thing that we need to do is make players appear when someone logs in. We need to make sure that the person logging in receives a list of all players that are currently <b>online</b> and we need to make sure everyone else spawns our new player on their game.</p>
<p >Let’s take a step back though and plan what we need to store about a <b>player</b>:</p><ul>
<li>Their X, Y <b>position</b> in the world.</li>
<li>Their <b>radius</b> (when they eat someone they’re going to get better).</li>
<li>Their <b>colour</b>.</li>
<li>Plus, in the future we might want to store a <b>name</b>.-</li>
</ul>
<p >Go ahead and make a new <code>Player</code> class on the <b>server</b> that stores those. If you’re lazy like me, copy and paste this code in: </p><div class="fragment"><div class="line"><span class="keyword">class </span>Player</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> ushort ID { <span class="keyword">get</span>; <span class="keyword">set</span>; }</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">float</span> X { <span class="keyword">get</span>; <span class="keyword">set</span>; }</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">float</span> Y { <span class="keyword">get</span>; <span class="keyword">set</span>; }</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">float</span> Radius { <span class="keyword">get</span>; <span class="keyword">set</span>; }</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">byte</span> ColorR { <span class="keyword">get</span>; <span class="keyword">set</span>; }</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">byte</span> ColorG { <span class="keyword">get</span>; <span class="keyword">set</span>; }</div>
<div class="line">    <span class="keyword">public</span> <span class="keywordtype">byte</span> ColorB { <span class="keyword">get</span>; <span class="keyword">set</span>; }</div>
<div class="line">    </div>
<div class="line">    <span class="keyword">public</span> Player(ushort ID, <span class="keywordtype">float</span> x, <span class="keywordtype">float</span> y, <span class="keywordtype">float</span> radius, <span class="keywordtype">byte</span> colorR, <span class="keywordtype">byte</span> colorG, <span class="keywordtype">byte</span> colorB)</div>
<div class="line">    {</div>
<div class="line">        this.ID = ID;</div>
<div class="line">        this.X = x;</div>
<div class="line">        this.Y = y;</div>
<div class="line">        this.Radius = radius;</div>
<div class="line">        this.ColorR = colorR;</div>
<div class="line">        this.ColorG = colorG;</div>
<div class="line">        this.ColorB = colorB;</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> I use <b>bytes</b> for the color because it means we have to store and send a lot <b>less data</b> than when using floats and it will serve the exact same purpose. Taking little steps like this can really improve bandwidth when you’re sending a message many times.</p>
<p >To <b>spawn</b> players we need to tell DarkRift to inform us when a player connects. In the constructor of <code>AgarPlayerManager</code> add the line: </p><div class="fragment"><div class="line">ClientManager.ClientConnected += ClientConnected;</div>
</div><!-- fragment --><p> And add a new method: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ClientConnected(<span class="keywordtype">object</span> sender, ClientConnectedEventArgs e)</div>
<div class="line">{</div>
<div class="line"> </div>
<div class="line">}</div>
</div><!-- fragment --><p> The <code>ClientManager</code> is responsible for keeping track of any clients that are connected to the <b>server</b> so you can use it to access clients and it can inform you when clients <b>connect</b> or <b>disconnect</b>. In this line, we’re <b>subscribing</b> to the <code>ClientConnected</code> event so whenever someone connects our method will be called with the <code>ClientManager</code> in sender and details of the connection in the <code>ClientConnectedArgs</code>.</p>
<p >Let’s give our newly connected player their own <code>Player</code> object. In our <code>ClientConnected</code> method add code to generate them a <b>new player</b> setup with random values: </p><div class="fragment"><div class="line">Random r = <span class="keyword">new</span> Random();</div>
<div class="line">Player newPlayer = <span class="keyword">new</span> Player(</div>
<div class="line">    e.Client.ID,</div>
<div class="line">    (<span class="keywordtype">float</span>)r.NextDouble() * MAP_WIDTH - MAP_WIDTH / 2,</div>
<div class="line">    (<span class="keywordtype">float</span>)r.NextDouble() * MAP_WIDTH - MAP_WIDTH / 2,</div>
<div class="line">    1f,</div>
<div class="line">    (<span class="keywordtype">byte</span>)r.Next(0, 200),</div>
<div class="line">    (<span class="keywordtype">byte</span>)r.Next(0, 200),</div>
<div class="line">    (<span class="keywordtype">byte</span>)r.Next(0, 200)</div>
<div class="line">);</div>
</div><!-- fragment --><p> And at the top of the class add a <code>MAP_WIDTH</code> constant: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> MAP_WIDTH = 20;</div>
</div><!-- fragment --><p> You might notice the sneaky <code>e.Client.ID</code> hiding in there. So that we can address the player when it’s on the Unity side we need to have an <b>identifier</b>, since the client will only have one <code>Player</code> object they control it’s sufficient to just use the server's ID that gets allocated to the client by DarkRift when it connects.</p>
<p >I’m using a value between 0 and 200 for each <b>colour</b> channel because if it’s too close to 255, 255, 255 we won’t be able to see the client against the <b>background</b>!</p>
<p >Next let’s send our new <code>Player</code> object to <b>all</b> the other <b>clients</b> so that they can spawn a new player in their games. Add the following just after: </p><div class="fragment"><div class="line"><span class="keyword">using</span> (DarkRiftWriter newPlayerWriter = DarkRiftWriter.Create())</div>
<div class="line">{</div>
<div class="line">    newPlayerWriter.Write(newPlayer.ID);</div>
<div class="line">    newPlayerWriter.Write(newPlayer.X);</div>
<div class="line">    newPlayerWriter.Write(newPlayer.Y);</div>
<div class="line">    newPlayerWriter.Write(newPlayer.Radius);</div>
<div class="line">    newPlayerWriter.Write(newPlayer.ColorR);</div>
<div class="line">    newPlayerWriter.Write(newPlayer.ColorG);</div>
<div class="line">    newPlayerWriter.Write(newPlayer.ColorB);</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> (Message newPlayerMessage = Message.Create(0, newPlayerWriter))</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">foreach</span> (IClient client <span class="keywordflow">in</span> ClientManager.GetAllClients().Where(x =&gt; x != e.Client))</div>
<div class="line">            client.SendMessage(newPlayerMessage, SendMode.Reliable);</div>
<div class="line">    }</div>
<div class="line">}</div>
</div><!-- fragment --><p> Whoa there! That got complicated quickly didn’t it!</p>
<p >Let’s look through each part. We need to <b>convert</b> our <code>Player</code> to something we can send over the network and currently it’s an unsigned short, 3 floats and 3 bytes, which isn’t compatible with the internet. The <code>DarkRiftWriter</code> and <code>DarkRiftReader</code> are objects provided for you to make that conversion easier, we <b>write</b> all our fields into the <b>writer</b> and on the Unity side we’ll <b>read</b> them off in the <b>same order</b> with a <b>reader</b>.</p>
<p >Next, we construct a <code>Message</code>. <b>Messages</b> essentially <b>wrap</b> data (all those values we stuffed into the <code>DarkRiftWriter</code>) and give them some simple header values that identify what the data actually <b>contains</b>. The first argument, <b>the tag</b>, is a single ushort that <b>identifies</b> what the message is about (think move player, use inventory object, send chat message etc.) and the second is our <b>data</b>. For now we can just use 0 as our tag.</p>
<p >Finally, we get <b>all clients</b> currently <b>connected</b> to the <b>server</b> using <code>ClientManager.GetAllClients()</code>, utilise a little LINQ to remove the client that just connected (we’ll deal with him later) and then <b>send</b> the message to <b>each</b> client. <b>Don’t forgot that when you call <code>GetAllClients()</code> the client that just connected has already been added!</b></p>
<p >See? Easy! What were you worried about?</p>
<p >In all seriousness though, that’s pretty much 80% of everything there is to sending messages in DarkRift, both client and server: create a <b>writer</b> for the <b>data</b>, a <b>message</b> to <b>wrap</b> the data and then <b>send</b>.</p>
<p >One thing I did gloss over, however, was the <code>SendMode</code>. This identifies how we should send the message to the client:</p><ul>
<li><code>Unreliable</code> – <b>No guarantees</b> will be made that the other device gets the message but it’s a lot <b>faster</b> to send. Use this for <b>frequent</b> data that will soon be out of date anyway (e.g. position/rotation updates).</li>
<li><code>Reliable</code> – The message is <b>guaranteed</b> to be delivered and large messages will be split up into smaller messages so that they can be sent.</li>
</ul>
<p >The next thing we need to do quickly is to spawn all other players on our newly connected player; since we want to minimise the bandwidth we use here we’re going to package it all into a single message and send it. Add the following line to the top of your <code>AgarPlayerManager</code>: </p><div class="fragment"><div class="line">Dictionary&lt;IClient, Player&gt; players = <span class="keyword">new</span> Dictionary&lt;IClient, Player&gt;();</div>
</div><!-- fragment --><p> And then add this to the end of your <code>ClientConnected</code> method: </p><div class="fragment"><div class="line">players.Add(e.Client, newPlayer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> (DarkRiftWriter playerWriter = DarkRiftWriter.Create())</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">foreach</span> (Player player <span class="keywordflow">in</span> players.Values)</div>
<div class="line">    {</div>
<div class="line">        playerWriter.Write(player.ID);</div>
<div class="line">        playerWriter.Write(player.X);</div>
<div class="line">        playerWriter.Write(player.Y);</div>
<div class="line">        playerWriter.Write(player.Radius);</div>
<div class="line">        playerWriter.Write(player.ColorR);</div>
<div class="line">        playerWriter.Write(player.ColorG);</div>
<div class="line">        playerWriter.Write(player.ColorB);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">using</span> (Message playerMessage = Message.Create(0, playerWriter))</div>
<div class="line">        e.Client.SendMessage(playerMessage, SendMode.Reliable);</div>
<div class="line">}</div>
</div><!-- fragment --><p> Hopefully this should be fairly self-explanatory from what we’ve already done, the only difference is that we keep writing into the <b>same writer</b> so that it’s all in <b>one message</b>. Note that we add the new player to the dictionary before enumerating over it so that it’s included in what we send to the player (otherwise they wouldn’t spawn themselves a player!)</p>
<p >Another thing we skipped over was the <code>using</code> statement. Messages, DarkRiftWriters and DarkRiftReaders all implement <code>IDisposable</code>, not because they contain resources that need disposing of, but because when we call <code>Dispose</code> they are returned to an object pool so that next time you call Create they don't have to be reallocated. Technically the using statements are completely optional but you'll get much better performance with them left in! We'll cover recycling in more depth in the Advanced section.</p>
<p >Finally, it’s a good idea to define <b>constants</b> for <b>tags</b> so that you can easily refer to them and modify them without side effects. Add a new file called <code>Tags</code> and put in a <b>static</b> class to collect all our tags: </p><div class="fragment"><div class="line"><span class="keyword">static</span> <span class="keyword">class </span>Tags</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> readonly ushort SpawnPlayerTag = 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> And change the tag parameter in both of the <code>Message.Create</code> calls to: <code>Tags.SpawnPlayerTag</code>.</p>
<h1><a class="anchor" id="autotoc_md227"></a>
Actually Spawning Players</h1>
<p >Now that we’ve written the server code for spawning players let’s add the <b>client</b> side code. Create a new file called <code>PlayerSpawner</code> in the Unity project and add the following code: </p><div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_namespace" href="namespace_dark_rift_1_1_client_1_1_unity.html">DarkRift.Client.Unity</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">public</span> <span class="keyword">class </span>PlayerSpawner : MonoBehaviour</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">const</span> <span class="keywordtype">byte</span> SPAWN_TAG = 0;</div>
<div class="line"> </div>
<div class="line">    [SerializeField]</div>
<div class="line">    [Tooltip(<span class="stringliteral">&quot;The %DarkRift client to communicate on.&quot;</span>)]</div>
<div class="line">    <a class="code hl_class" href="class_dark_rift_1_1_client_1_1_unity_1_1_unity_client.html">UnityClient</a> client;</div>
<div class="line"> </div>
<div class="line">    [SerializeField]</div>
<div class="line">    [Tooltip(<span class="stringliteral">&quot;The controllable player prefab.&quot;</span>)]</div>
<div class="line">    GameObject controllablePrefab;</div>
<div class="line"> </div>
<div class="line">    [SerializeField]</div>
<div class="line">    [Tooltip(<span class="stringliteral">&quot;The network controllable player prefab.&quot;</span>)]</div>
<div class="line">    GameObject networkPrefab;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> Awake()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (client == <span class="keyword">null</span>)</div>
<div class="line">        {</div>
<div class="line">            Debug.LogError(<span class="stringliteral">&quot;Client unassigned in PlayerSpawner.&quot;</span>);</div>
<div class="line">            Application.Quit();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (controllablePrefab == <span class="keyword">null</span>)</div>
<div class="line">        {</div>
<div class="line">            Debug.LogError(<span class="stringliteral">&quot;Controllable Prefab unassigned in PlayerSpawner.&quot;</span>);</div>
<div class="line">            Application.Quit();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> (networkPrefab == <span class="keyword">null</span>)</div>
<div class="line">        {</div>
<div class="line">            Debug.LogError(<span class="stringliteral">&quot;Network Prefab unassigned in PlayerSpawner.&quot;</span>);</div>
<div class="line">            Application.Quit();</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        client.MessageReceived += SpawnPlayer;</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_dark_rift_1_1_client_1_1_unity_1_1_unity_client_html"><div class="ttname"><a href="class_dark_rift_1_1_client_1_1_unity_1_1_unity_client.html">DarkRift.Client.Unity.UnityClient</a></div><div class="ttdef"><b>Definition:</b> UnityClient.cs:34</div></div>
<div class="ttc" id="anamespace_dark_rift_1_1_client_1_1_unity_html"><div class="ttname"><a href="namespace_dark_rift_1_1_client_1_1_unity.html">DarkRift.Client.Unity</a></div><div class="ttdef"><b>Definition:</b> UnityClientEditor.cs:30</div></div>
</div><!-- fragment --><p >In this you’ll notice we define a <b>reference</b> to a <code>UnityClient</code> object that we’ll fill from the <b>inspector</b>. This is the <b>component</b> that handles our <b>connection</b> to the server, we added it to the <code>Network</code> object in our Unity scene earlier, remember?</p>
<p >The <code>MessageReceived</code> event we <b>subscribe</b> to is called whenever the client <b>receives</b> a message from the server. You can subscribe as many different handlers to this as you like but having <b>fewer</b> is generally easier to maintain and a little <b>faster</b>.</p>
<p >One other important thing to note is that we call this from <code>Awake</code>. When you have the <code>UnityClient</code> set to connect in the Start routine it is important to make sure that you subscribe for all initial messages from <code>Awake</code> because otherwise you might miss messages if it connects before you subscribe!</p>
<p >Add the following code to <b>decode</b> our spawn packets: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> SpawnPlayer(<span class="keywordtype">object</span> sender, <a class="code hl_class" href="class_dark_rift_1_1_client_1_1_message_received_event_args.html">MessageReceivedEventArgs</a> e)</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using</span> (<a class="code hl_class" href="class_dark_rift_1_1_message.html">Message</a> message = e.<a class="code hl_function" href="class_dark_rift_1_1_client_1_1_message_received_event_args.html#a1c8f545780f139571791f3edf6825f2c">GetMessage</a>())</div>
<div class="line">    <span class="keyword">using</span> (<a class="code hl_class" href="class_dark_rift_1_1_dark_rift_reader.html">DarkRiftReader</a> reader = message.<a class="code hl_function" href="class_dark_rift_1_1_message.html#aa51501a07e371151a0c45a562a002741">GetReader</a>())</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">if</span> (message.<a class="code hl_property" href="class_dark_rift_1_1_message.html#a4ea7394466760b94c49ead8ab9ace20c">Tag</a> == Tags.SpawnPlayerTag)</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (reader.Length % 17 != 0)</div>
<div class="line">            {</div>
<div class="line">                Debug.LogWarning(<span class="stringliteral">&quot;Received malformed spawn packet.&quot;</span>);</div>
<div class="line">                <span class="keywordflow">return</span>;</div>
<div class="line">            }</div>
<div class="line"> </div>
<div class="line">            <span class="keywordflow">while</span> (reader.Position &lt; reader.Length)</div>
<div class="line">            {</div>
<div class="line">                ushort <span class="keywordtype">id</span> = reader.ReadUInt16();</div>
<div class="line">                Vector3 position = <span class="keyword">new</span> Vector3(reader.ReadSingle(), reader.ReadSingle());</div>
<div class="line">                <span class="keywordtype">float</span> radius = reader.ReadSingle();</div>
<div class="line">                Color32 color = <span class="keyword">new</span> Color32(</div>
<div class="line">                    reader.ReadByte(), </div>
<div class="line">                    reader.ReadByte(), </div>
<div class="line">                    reader.ReadByte(),</div>
<div class="line">                    255</div>
<div class="line">                );</div>
<div class="line">    </div>
<div class="line">                GameObject obj;</div>
<div class="line">                <span class="keywordflow">if</span> (<span class="keywordtype">id</span> == client.<a class="code hl_property" href="class_dark_rift_1_1_client_1_1_unity_1_1_unity_client.html#ae274d01f49fa9cba3f1098db826ce6aa">ID</a>)</div>
<div class="line">                {</div>
<div class="line">                    obj = Instantiate(controllablePrefab, position, Quaternion.identity) as GameObject;</div>
<div class="line">                }</div>
<div class="line">                else</div>
<div class="line">                {</div>
<div class="line">                    obj = Instantiate(networkPrefab, position, Quaternion.identity) as GameObject;</div>
<div class="line">                }</div>
<div class="line"> </div>
<div class="line">                AgarObject agarObj = obj.GetComponent&lt;AgarObject&gt;();</div>
<div class="line"> </div>
<div class="line">                agarObj.SetRadius(radius);</div>
<div class="line">                agarObj.SetColor(color);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_dark_rift_1_1_client_1_1_message_received_event_args_html"><div class="ttname"><a href="class_dark_rift_1_1_client_1_1_message_received_event_args.html">DarkRift.Client.MessageReceivedEventArgs</a></div><div class="ttdoc">Arguments for MessageReceived events.</div><div class="ttdef"><b>Definition:</b> MessageReceivedEventArgs.cs:18</div></div>
<div class="ttc" id="aclass_dark_rift_1_1_client_1_1_message_received_event_args_html_a1c8f545780f139571791f3edf6825f2c"><div class="ttname"><a href="class_dark_rift_1_1_client_1_1_message_received_event_args.html#a1c8f545780f139571791f3edf6825f2c">DarkRift.Client.MessageReceivedEventArgs.GetMessage</a></div><div class="ttdeci">Message GetMessage()</div><div class="ttdoc">Gets the message received.</div><div class="ttdef"><b>Definition:</b> MessageReceivedEventArgs.cs:68</div></div>
<div class="ttc" id="aclass_dark_rift_1_1_client_1_1_unity_1_1_unity_client_html_ae274d01f49fa9cba3f1098db826ce6aa"><div class="ttname"><a href="class_dark_rift_1_1_client_1_1_unity_1_1_unity_client.html#ae274d01f49fa9cba3f1098db826ce6aa">DarkRift.Client.Unity.UnityClient.ID</a></div><div class="ttdeci">ushort ID</div><div class="ttdoc">The ID the client has been assigned.</div><div class="ttdef"><b>Definition:</b> UnityClient.cs:202</div></div>
<div class="ttc" id="aclass_dark_rift_1_1_dark_rift_reader_html"><div class="ttname"><a href="class_dark_rift_1_1_dark_rift_reader.html">DarkRift.DarkRiftReader</a></div><div class="ttdoc">Helper class for converting byte buffers into their original components during deserialization.</div><div class="ttdef"><b>Definition:</b> DarkRiftReader.cs:28</div></div>
<div class="ttc" id="aclass_dark_rift_1_1_message_html"><div class="ttname"><a href="class_dark_rift_1_1_message.html">DarkRift.Message</a></div><div class="ttdoc">Message class for all messages sent through DarkRift.</div><div class="ttdef"><b>Definition:</b> Message.cs:21</div></div>
<div class="ttc" id="aclass_dark_rift_1_1_message_html_a4ea7394466760b94c49ead8ab9ace20c"><div class="ttname"><a href="class_dark_rift_1_1_message.html#a4ea7394466760b94c49ead8ab9ace20c">DarkRift.Message.Tag</a></div><div class="ttdeci">ushort Tag</div><div class="ttdoc">The tag of the message.</div><div class="ttdef"><b>Definition:</b> Message.cs:138</div></div>
<div class="ttc" id="aclass_dark_rift_1_1_message_html_aa51501a07e371151a0c45a562a002741"><div class="ttname"><a href="class_dark_rift_1_1_message.html#aa51501a07e371151a0c45a562a002741">DarkRift.Message.GetReader</a></div><div class="ttdeci">DarkRiftReader GetReader()</div><div class="ttdoc">Creates a DarkRiftReader to read the data in the message.</div><div class="ttdef"><b>Definition:</b> Message.cs:312</div></div>
</div><!-- fragment --><p> If you take a careful look into the code you’ll see that we just <b>reverse</b> the packaging process we did before: we get a <b>reader</b> from the <b>message</b> that contains the message data and simply loop through reading the data out in the same order we wrote it on (note, <b>order matters</b> here!) until there is no more data left. As we read through we create the necessary objects depending on whether the <b>ID</b> of the player object is our ID (if it is then that should be the object we’re <b>controlling</b>).</p>
<p >Add the <code>PlayerSpawner</code> component to the <code>Network</code> object in the scene and drag onto it the <code>Client</code> and <b>both prefabs</b> in their respective places.</p>
<p >Lastly, <b>copy</b> the <code>Tags</code> file from the <b>plugin</b> so we have an identical copy in our Unity project.</p>
<p >You should now be able to test and see a player spawn on the client. Next step, movement! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
